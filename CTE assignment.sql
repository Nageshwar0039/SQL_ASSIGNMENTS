use mavenmovies;


-- 1. CTE for Recrusive Search :
-- Implement a recursive CTE to find all employees in the staff table who report to a specific manager_store_id in the table store , considering the column.

WITH RECURSIVE EmployeeHierarchy AS (
    SELECT employee_id, manager_id
    FROM staff
    WHERE manager_id = <specific_manager_id> -- Specify the manager ID you're interested in

    UNION ALL

    SELECT s.employee_id, s.manager_id
    FROM staff s
    JOIN EmployeeHierarchy eh ON s.manager_id = eh.employee_id
)
SELECT * FROM EmployeeHierarchy;


-- 2. CTE and SelfJoin
-- Create a CTE to generate a report showing pairs of actors who have appeared in the same film together,
-- using the film_actor table

WITH ActorsInSameFilm AS (
    SELECT fa1.actor_id AS actor1_id, fa2.actor_id AS actor2_id, f.title AS film_title
    FROM film_actor fa1
    JOIN film_actor fa2 ON fa1.film_id = fa2.film_id AND fa1.actor_id < fa2.actor_id
    JOIN film f ON fa1.film_id = f.film_id
)
SELECT actor1_id, actor2_id, film_title
FROM ActorsInSameFilm;


-- 3. CTE for Pivot Operations
-- Use a CTE to pivot the data from the payment table to display the total payments made by each customer in separate columns for
--  different payment methods

WITH PaymentPivot AS (
    SELECT 
        customer_id,
        SUM(CASE WHEN payment_method = 'Cash' THEN amount ELSE 0 END) AS total_cash_payments,
        SUM(CASE WHEN payment_method = 'Credit Card' THEN amount ELSE 0 END) AS total_credit_card_payments,
        SUM(CASE WHEN payment_method = 'Debit Card' THEN amount ELSE 0 END) AS total_debit_card_payments,
        SUM(CASE WHEN payment_method = 'Check' THEN amount ELSE 0 END) AS total_check_payments
    FROM payment
    GROUP BY customer_id
)
SELECT * FROM PaymentPivot;


-- 4. CTE for  Date Calculations :
-- Write a query using a CTE to find the total number of rentals made each month, considering the rental_date
-- from the table rental

WITH RentalCounts AS (
    SELECT 
        EXTRACT(YEAR_MONTH FROM rental_date) AS rental_month,
        COUNT(*) AS total_rentals
    FROM rental
    GROUP BY rental_month
)
SELECT rental_month, total_rentals
FROM RentalCounts
ORDER BY rental_month;


-- 5. CTE and Filtering :
-- Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer
-- table to retrieve additional customer details

WITH CustomersWithMoreThanTwoRentals AS (
    SELECT 
        customer_id,
        COUNT(*) AS total_rentals
    FROM rental
    GROUP BY customer_id
    HAVING COUNT(*) > 2
)
SELECT c.*, cmr.total_rentals
FROM customer c
JOIN CustomersWithMoreThanTwoRentals cmr ON c.customer_id = cmr.customer_id;


-- 6. CTE with Window Functions :
-- Utilize a CTE with a window function to rank films based on their rental duration from the table film.

WITH FilmRentalRank AS (
    SELECT
        film_id,
        title,
        rental_duration,
        ROW_NUMBER() OVER (ORDER BY rental_duration DESC) AS rental_rank
    FROM film
)
SELECT film_id, title, rental_duration, rental_rank
FROM FilmRentalRank;


-- 7. CTE for Aggregation :
-- Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from
-- the customer and payment table

WITH CustomerRevenue AS (
    SELECT 
        c.customer_id,
        c.first_name,
        c.last_name,
        SUM(p.amount) AS total_revenue
    FROM customer c
    JOIN payment p ON c.customer_id = p.customer_id
    GROUP BY c.customer_id, c.first_name, c.last_name
)
SELECT customer_id, first_name, last_name, total_revenue
FROM CustomerRevenue;


-- 8. CTE with Joins :
-- Create a CTE that combines information from the film and language tables to display the film title,
-- language name, and rental rate

WITH FilmLanguageInfo AS (
    SELECT 
        f.title AS film_title,
        l.name AS language_name,
        f.rental_rate
    FROM film f
    JOIN language l ON f.language_id = l.language_id
)
SELECT film_title, language_name, rental_rate
FROM FilmLanguageInfo;


-- 9. Recursive CTE :
-- Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the
-- category table in Sakila database

WITH RECURSIVE CategoryHierarchy AS (
    SELECT 
        fc.category_id AS category_id,
        c.name AS category_name,
        fc.category_id AS parent_id,
        0 AS level
    FROM film_category fc
    JOIN category c ON fc.category_id = c.category_id
    WHERE NOT EXISTS (
        SELECT 1 
        FROM film_category sub_fc 
        WHERE sub_fc.film_id = fc.category_id
    )

    UNION ALL

    SELECT 
        fc.category_id,
        c.name,
        fc.category_id AS parent_id,
        ch.level + 1
    FROM film_category fc
    JOIN category c ON fc.category_id = c.category_id
    JOIN CategoryHierarchy ch ON fc.film_id = ch.category_id
)
SELECT category_id, category_name, parent_id, level
FROM CategoryHierarchy
ORDER BY level, category_id;


-- 10. CTE Basics :
-- Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have
-- acted in from the actor and film_actor tables

WITH ActorFilmCounts AS (
    SELECT 
        fa.actor_id,
        a.first_name,
        a.last_name,
        COUNT(*) AS film_count
    FROM film_actor fa
    JOIN actor a ON fa.actor_id = a.actor_id
    GROUP BY fa.actor_id, a.first_name, a.last_name
)
SELECT first_name, last_name, film_count
FROM ActorFilmCounts;


-- 11. Normalization Process :
-- Take a specific table in Sakiladatabase and guide through the process of normalizing it from the initial
-- unnormalized form up to at least 2NF

-- Let's take a specific table from the Sakila database and guide through the process of normalizing it up to at least 2NF.
-- We'll use the film table for this example.
-- Step 1: Understanding the Initial Unnormalized Form (UNF)
--         The film table in the Sakila database contains information about films.Here's how the table might look
           select * from film;

-- Step 2: Identify Dependencies and Primary Key
--         We need to identify functional dependencies and the primary key.
--         Primary Key: film_id
--         Functional Dependencies:
--              film_id → title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost, rating, special_features, last_update
--              language_id → name (from the language table)

-- Step 3: Normalize to 1NF
--         Ensure that each column contains atomic values.
--         The film table is already in 1NF because each cell contains a single value.

-- Step 4: Normalize to 2NF
--         Remove partial dependencies by moving columns that depend on only part of the primary key into a separate table.
--         In our case, there are no partial dependencies. The entire primary key (film_id) determines all other attributes.

-- Step 5: Create New Tables
--         Scence we have the table "language", unless creating a new table we will use existing table "language"
--         You would then join the film table with the language table to retrieve the language name based on the language_id. 
--         This would ensure data integrity and eliminate redundancy in your database schema.
           SELECT f.*, l.name FROM film f JOIN language l ON f.language_id = l.language_id;

-- Step 6:  Modify Existing Table (Adjustments needed)
--          Remove redundant columns (language_name) from the film table.
            ALTER TABLE film DROP COLUMN language_name;
--  Final Result
-- You'd end up with a normalized film table, removing the redundant language_name column, 
-- and utilizing the existing language table to retrieve the language name.

-- 12.  FIRST NORMAL FORM :
--                    First Normal Form (1NF) is the first step in the normalization process of database design. It sets the most basic requirements for a table, ensuring that it contains only atomic values and does not have repeating groups of attributes or columns. In 1NF:
-- Each table cell should contain a single value, meaning each attribute (column) should hold only atomic (indivisible) values.
-- There should be no repeating groups or arrays within a table. Each column should contain only scalar values (values that cannot be divided further).
-- Every column should have a unique name, and the order of columns should not matter.
-- To comply with 1NF, you might need to split tables with repeating groups of data into separate tables, ensure that each column contains only atomic values, and ensure that each attribute has a unique name.
-- Violations of 1NF can lead to data redundancy, difficulties in data manipulation, and potential inconsistencies. Therefore, achieving 1NF is the first step towards well-structured, normalized database design.
-- EXAMPLE - CUSTOMER TABLE

-- 13. SECOND NORMAL FORM :
--                    Second Normal Form (2NF) is a step further in the normalization process of database design. 
-- It builds upon the requirements of First Normal Form (1NF) and addresses issues related to partial dependencies.
-- It must already be in 1NF.
-- All non-prime attributes (attributes not part of any candidate key) must be fully functionally dependent on the entire primary key.
-- In simpler terms, 2NF eliminates partial dependencies by ensuring that every non-prime attribute is dependent on the entire primary key, 
-- rather than just part of it.

-- To achieve 2NF, tables may need to be decomposed further if non-prime attributes depend on only a portion of the primary key. 
-- This decomposition typically results in creating separate tables for attributes that exhibit partial dependencies.

-- 2NF helps in improving data integrity and reducing data redundancy by structuring the database in such a way 
-- that data dependencies are accurately represented. It lays the groundwork for further normalization and optimization of the database schema.
-- example - language table 

-- 14. THIRD NORMAL FORM :
--                   Third Normal Form (3NF) is a further step in the normalization process of database design. 
-- It builds upon the requirements of First Normal Form (1NF) and Second Normal Form (2NF) and addresses issues related to transitive dependencies.
-- A table is in 3NF if it satisfies the following conditions:
-- It is in 2NF.
-- It does not have any transitive dependencies.
-- In simpler terms, 3NF eliminates transitive dependencies by ensuring that every non-prime attribute is 
-- directly dependent on the primary key and not on any other non-prime attribute.

-- Transitive dependency occurs when a non-prime attribute depends on another non-prime attribute rather
-- than directly on the primary key. To achieve 3NF, tables may need to be decomposed further to remove such dependencies and ensure data integrity.

-- 3NF helps in improving data integrity, reducing data redundancy, and preventing update anomalies by structuring the 
-- database in such a way that data dependencies are accurately represented and minimized.

In summary, 3NF is an important stage in the normalization process that ensures the database schema is well-structured, free from anomalies, and optimized for efficient data storage and retrieval.